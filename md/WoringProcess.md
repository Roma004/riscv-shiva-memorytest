# Заметки о написании проекта

Первая либа [эта](https://github.com/sifive/freedom-metal/tree/1cec4a23a7ed7350db79a392be65acd51acd5412), что гуглится и засирает половину первой страницы поиска написана неочевидно, так что, её, пропустил сразу практически. Примеров кода подцепить от туда не удалось, как и каких-либо концепций.

Из того, что на первых порах нашёл в пойске была вот [эта](https://github.com/diodesign/mmio_sifive_uart/blob/main/src/lib.rs) либа на расте. Там очень незаморочено реализован минимальный драйвер UART модуля. Это код подтвердил мои предположения, что ничего, кроме записей по различным адресам мне в этом проекте делать не надо будет.

В поисках кросс-компилятора сразу загуглил, как поставить уже собранный на archlinux, но когда увидел, что из себя найденный AUR пакет представляет, решил, что будет правильнее самостоятельно скачать [этот](https://github.com/riscv-collab/riscv-gnu-toolchain/releases/tag/2023.07.07) nightly релиз под убунту, и положить куда мне надо.

Я переписал код с раста на С, но он не заработал (я бы больше удивился, противоположному результату). Несколько запусков кода, не показывающего никаких признаков жизни, но компилирующегося показали необходимость либо искать гайд по настройке окружения, либо конкретно дебаггера.

В результате усиленного гугления наткнулся на [этот](https://twilco.github.io/riscv-from-scratch/2019/04/27/riscv-from-scratch-2.html) цикл статей. После вдумчивого прочтения многое встало на свои места. Я настроил отладчик, линкер, файлик с точкой вхождения кода (который перед вызовом main переставляет sp в начало стека), и перепроверил весь С код, написанный ранее.

Код начал подавать признаки жизни, но выводил строку не так, как предполагалось (байты дублировались, накладывались друг на друга, выводились не все и т.д.). После нескольких попыток понять, что не так, пришёл к выводу, что надо запускать с флагом -O0. Так же, поменял размер буффера, из которого я пишу символы в UART (поставил 2 байта). Оно стало работать нормально, но чудило при включении оптимизаций. Эту проблему решил отложить на потом

Ещё без флага компиляции -mabi=lp64 у меня дебаггер не хотел начинать отлаживать код из-за несовместимого набора инструкций (как я понял). А без флага `-mcmodel=medany` происходила какая-то фигня, и компилятор выдавал ошибку, что ему не то места не хватает на стеке, не то, ещё что-то. Но на гитхабе где-то нашёл, ответ что этот флаг иногда помогает

Теперь пришло время гуглить, что такое DMA, и как с ним работать. По-сути, это чип, который умеет перекладывать байты буфферами с одного места на другое без участия процессора. В общем, мне надо memcpy реализовать через API DMA. Дальше гайдами не пользовался, так как не нашёл их. Прочитал офф. доку по DMA для `fu540-c000-pdma` Очень помогло понимане концепции работы с различными устройствами в упомянутом выше цикле статей по настройке окружения. 

Исходя из доки, всё, что мне надо - зарезервировать канал, записать регистры (memory-mapped) правильным образом -- передать настройки трансфера пакетов, кол-во байт и адреса откуда и куда писать. В течении нескольких часов реализовал базовый драйвер, исходя из написанного в доке, но он не завёлся. Ещё около 5 часов отладки привели меня к довольно полезной ссылке на [реализацию](https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/dma/sf-pdma/sf-pdma.c?h=v6.3.12) этого драйвера под линь (вот ещё [заголовок](https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/dma/sf-pdma/sf-pdma.h?h=v6.3.12)), и к некой адаптации в GDB (я вспомнил, как это делается спустя полтора года). Только не помогло решить проблему.

Без помощи научрука не удалось найти довольно неочевидный, на первый взгляд, косяк, что в пункте доки про расположение регистров в одну таблицу написали сдвиг каналов для обработки прерываний и сдвиг регистров конфигурации этих каналов. Можно было подумать, что сдвиг 0x8_0000 (каналов, на самом деле) - сдвиг регистров, а оказалось, всё наоборот. Пока я не перечитал раздел 12.2 вплоть до каждого слова, я даже бы не подумал об этом.

В общем, после решения этого DMA драйвер завёлся, и мне удалось скопировать строку со стека на стек. Теперь привожу код в порядок, и иду думать, как лучше организовывать запись шаблона в оперативу
